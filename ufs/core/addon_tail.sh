#!/sbin/sh
#	
#	uniFlashScript
#
#	CodRLabworks
#	CodRCA : Christian Arvin
#

. /tmp/backuptool.functions


# INSTALLER.SH AUTOGENERATED DEF.
# _____________________________________________________________________________ <- 80 char
#

# ! AUTOGENERATED BY INSTALLER.SH !
addon_name=null
addon_src_ver=null
addon_app_rev=null

# ! AUTOGENERATED BY INSTALLER.SH !
wipe_list="
"

# ! AUTOGENERATED BY INSTALLER.SH !
list_files() {
cat <<EOF
EOF
}

# Local Functions
# _____________________________________________________________________________ <- 80 char
#

# Initial ui_print Function 
ui_print(){
	echo -n -e "ui_print $1\n" >> /proc/self/fd/$OUTFD
	echo -n -e "ui_print\n" >> /proc/self/fd/$OUTFD
	
	[ -n "$1" ] && file_log "$1"
}

# Cold Log
file_log() {
	[ -n "$1" ] && IN="$1" || read IN
	echo "$(date "+%H:%M:%S") $IN" >> $COLD_TMP
	printf "$IN\n"
}

# ASLIB EXPORTED FUNCTIONS
# _____________________________________________________________________________ <- 80 char
#

# REDIRECT ASLIB LOGGING TO LOCAL LOGGING
LT1=file_log;LT2=file_log;LT3=file_log;LT4=file_log;

##### ASLIB.SET_PERM
set_perm() {
	$LT2 "I: ASLIB set_perm: setting permission $1 - $2 $3 $4 $5"
	[[ -n "$1" && -n "$2" && -n "$3" && -n "$4" ]] && {
		chown $1.$2 $4
		chown $1:$2 $4
		chmod $3 $4
	}
	
	[ -n "$4" ] && {
		ch_con $4
		[ -n "$5" ] && ch_con_ext $4 $5
	}
}

##### ASLIB.SUB.CH_CON
ch_con() {
	$LT4 "D: ASLIB exec ch_con"
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toybox chcon -h u:object_r:system_file:s0 $1  >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/toolbox chcon -h u:object_r:system_file:s0 $1     >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toolbox chcon -h u:object_r:system_file:s0 $1 >/dev/null 2>&1
	chcon -h u:object_r:system_file:s0 $1                                                >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toybox chcon u:object_r:system_file:s0 $1     >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/toolbox chcon u:object_r:system_file:s0 $1        >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toolbox chcon u:object_r:system_file:s0 $1    >/dev/null 2>&1
	chcon u:object_r:system_file:s0 $1                                                   >/dev/null 2>&1
}

##### ASLIB.SUB.CH_CON_EXT
ch_con_ext() { # sub-function of set_perm
	$LT4 "D: ASLIB exec ch_con_ext"
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toybox chcon $2 $1   >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/toolbox chcon $2 $1	  	>/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toolbox chcon $2     >/dev/null 2>&1
	chcon $2 $1                                                 >/dev/null 2>&1
}


# ASLIB.SUB.PRINT_HEADER
print_header(){
	set=0;tmh_init=false;

	while true;do
		eval val='$'TMH${set}
		if [ "$val" == "#" ];then
			ui_print " "
		elif [ -n "$val" ]; then
			ui_print "$val"
		elif [ -z "$val" ]; then
			# ignore the first blank TMH
			[ "$tmh_init" == "true" ] && {
				break
			}
			tmh_init=true
		fi
		set=$((++set))
	done
}

##### ASLIB.SUB.IS_MOUNTED
is_mounted() {
	$LT4 "D: ASLIB exec is_mounted with $1 $2"
	[ -n "$2" ] && {
		cat /proc/mounts | grep $1 | grep $2, >/dev/null 2>&1
		s=$?
	} || {
		cat /proc/mounts | grep $1            >/dev/null 2>&1
		s=$?
	}
	[ "$s" == "0" ] && \
	$LT4 "D: ASLIB is_mounted: $1 is mounted $2" || \
	$LT4 "D: ASLIB is_mounted: $1 is not mounted"
	return $s
}

###### ASLIB.SUB.IS_ENABLED
is_enabled() {
	$LT4 "D: ASLIB exec is_enabled with $1"
	[ -z "$1" ] && return 1
	eval ie_t='$'$1
	case $ie_t in
		1|enable|true|True|TRUE|ENABLED|ENABLE) 
			$LT4 "I: ASLIB is_enabled: ENABLED, by $1 set to $ie_t"
			s=0
		;;
		0|disable|false|False|FALSE|DISABLED|DISABLE|' ')
			$LT4 "I: ASLIB is_enabled: DISABLED, by $1 set to $ie_t"
			s=1
		;;
		*) 	$LT4 "E: ASLIB is_enabled: unknown state of $1 set to $ie_t, returning 1"
			s=1
		;;
	esac
	return $s
}

##### ASLIB.SUB.TOOLBOX_MOUNT
toolbox_mount() {
	$LT4 "D: ASLIB exec toolbox_mount $1 $2"
	# default to READ_WRITE
	local RW=rw
	[ ! -z "$2" ] && RW=$2
	
	$LT4 "D: ASLIB toolbox_mount: mounting using using /etc/fstab entry"

	local DEV=;
	local POINT=;
	local FS=;
	
	for i in `cat /etc/fstab | grep "$1"`; do
		if [ -z "$DEV" ]; then
			DEV=$i
		elif [ -z "$POINT" ]; then
			POINT=$i
		elif [ -z "$FS" ]; then
			  FS=$i
			break
		fi
	done
	
	$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW $DEV $POINT"
	! mount -t $FS -o $RW $DEV $POINT               >/dev/null 2>&1 && \
	$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW,remount $DEV $POINT" && \
	! mount -t $FS -o $RW,remount $DEV $POINT       >/dev/null 2>&1 || return 0
	
	
	$LT4 "D: ASLIB toolbox_mount: mounting using using /etc/recovery.fstab"
	
	DEV=;POINT=;FS=;
	
	for i in `cat /etc/recovery.fstab | grep "$1"`; do
		if [ -z "$POINT" ]; then
			POINT=$i
		elif [ -z "$FS" ]; then
			FS=$i
		elif [ -z "$DEV" ]; then
			DEV=$i
			break
		fi
	done
	
	if [ "$FS" = "emmc" ]; then
		$LT4 "D: ASLIB toolbox_mount: exec mount -t ext4 -o $RW $DEV $POINT"
		! mount -t ext4 -o $RW $DEV $POINT            >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t ext4 -o $RW,remount $DEV $POINT" && \
		! mount -t ext4 -o $RW,remount $DEV $POINT    >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t f2fs -o $RW $DEV $POINT" && \
		! mount -t f2fs -o $RW $DEV $POINT            >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t f2fs -o $RW,remount $DEV $POINT" && \
		! mount -t f2fs -o $RW,remount $DEV $POINT    >/dev/null 2>&1 || return 0
	else
		$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW $DEV $POINT"
		! mount -t $FS -o $RW $DEV $POINT             >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW,remount $DEV $POINT" && \
		! mount -t $FS -o $RW,remount $DEV $POINT     >/dev/null 2>&1 || return 0
	fi
	return 1 # FAILED TO MOUNT
}


##### ASLIB.SUB.REMOUNT_MOUNTPOINT
remount_mountpoint() {
	$LT4 "D: ASLIB exec remount_mountpoint"
	[ -n "$*" ] && {
		! is_mounted $1 $2 && \
		$LT4 "D: ASLIB remount_mountpoint: exec mount -o $2,remount $1" && \
		! mount -o $2,remount $1    >/dev/null 2>&1 && \
		$LT4 "D: ASLIB remount_mountpoint: exec mount -o $2,remount $1 $1" && \
		! mount -o $2,remount $1 $1 >/dev/null 2>&1 && \
		$LT4 "D: ASLIB remount_mountpoint: exec toolbox_mount $1" && \
		! toolbox_mount $1          >/dev/null 2>&1 && \
		{
			$LT3 "I: ASLIB remount_mountpoint: $1 failed to remount"
			stat=1
		} || {
			$LT3 "I: ASLIB remount_mountpoint: $1 remounted successfully"
			stat=0
		}
		return $stat
	}
}

###### ASLIB.SUB.SET_SYSTEM_FP
set_system_fp() {
	$LT4 "D: ASLIB exec set_system_fp"
	[[ "$(echo ${1} | cut -d / -f 2-2)" != "system" ]] && {
		$LT2 "E: ASLIB set_system_fp: not valid system file input $1"
		$LT3 "W: ASLIB set_system_fp: only system files with full path are accepted"
	}
	
	local _sys="$(echo ${1} | cut -d / -f 3-3)"
	
	case $_sys in
		bin|xbin)
			set_perm 0 2000 0755 $1
			chmod +x $1
		;;
		vendor)
			local _sysv="$(echo ${1} | cut -d / -f 4-4)"
			case $_sysv in
				bin|xbin)
				set_perm 0 2000 0755 $1
				chmod +x $1
				;;
				*)
				set_perm 0 0 0655 $1
				;;
			esac
		;;
		*)
			set_perm 0 0 0655 $1
		;;
	esac
}


# Pre-Initialization
# _____________________________________________________________________________ <- 80 char
#

# CREATE A TEMP. PLACEHOLDER FOR LOGGING
COLD_TMP=/tmp/$addon_name.log

# CREATE THE COLD LOG HEADER
[ ! -e $COLD_TMP ] && {
	file_log " "
	file_log "uniFlashScript addon.d logs"
	file_log " "
	file_log "$addon_name"
	file_log "src ver. : $addon_src_ver"
	file_log "src rev. : $addon_app_rev"$'\n\n\n'
}

# CUSTOM UI_PRINT HEADER
# ! LEAVE THIS PART !
TMH0=""
TMH1="#"
# ! BEGIN HEADER HERE !
TMH2=""

# FD FAILSAFE
OUTFD=`ps | grep -v grep | grep -oE "update(.*)" | cut -d" " -f3`

# Initialization
# _____________________________________________________________________________ <- 80 char
#

# CREATE THE DIRECTORY OTA LOG
# by uniFlashScript standard..
[ ! -e /sdcard/logs/ufs/ota ] && {
	file_log "I: $addon_name: creating ota directory"
	install -d /sdcard/logs/ufs/ota
}

# OVIRRIDE C DEF. AND REDIRECT TO SDCARD
C=/sdcard/tmp_ufs_ota

# CREATE TEMP FILE HOLDER
[ ! -e $C ] && mkdir $C

# Main
# _____________________________________________________________________________ <- 80 char
#

case "$1" in
  backup)
	# print_header
	TMH1="backup $addon_name "
	print_header
	
	# Safely Check that SDCARD is mounted
	remount_mountpoint /sdcard rw
	
	# Backup
	file_log "I: $addon_name: backing_up files"
	list_files | while read FILE DUMMY; do
		backup_file $S/"$FILE"
		[ -e $C/system/$FILE ] && {
			file_log "I: $addon_name: success :$C/system/$FILE"
		} || {
			file_log "E: $addon_name: FAILED  :$S/$FILE"
		} 
	done
  ;;
  restore)
	# print_header
	TMH1="restore $addon_name "
	print_header
	
	# Safely Check that SDCARD is mounted
	remount_mountpoint /sdcard rw
	
	file_log "I: $addon_name: wiping files"
	# Wipe files
	for m in $wipe_list;do
		rm -rf /system/$m
		[ -e /system/$m ] && {
			file_log "E: $addon_name: FAILED  :/system/$m"
		} || {
			file_log "I: $addon_name: removed :/system/$m"
		}
	done
	
	# Install
	file_log "I: $addon_name: restoring files"
	list_files | while read FILE REPLACEMENT; do
		R=""
		[ -n "$REPLACEMENT" ] && R="$S/$REPLACEMENT"
		[ -f "$C/$S/$FILE"  ] && (
			restore_file $S/"$FILE" "$R"
			[ -e $S/"$FILE" ] && {
				file_log "I: $addon_name: installed :$S/$FILE"
			} || {
				file_log "E: $addon_name: FAILED    :$S/$FILE"
			}
		)
	done
  ;;
  pre-backup)
	# Stub
  ;;
  post-backup)
	# Stub
  ;;
  pre-restore)
	# Stub
  ;;
  post-restore)
	# print_header
	TMH1="post-restore $addon_name "
	print_header
	
	
	# Setup Correct Permissions
	file_log "I: $addon_name: setting permisions"
	for i in $(list_files); do
		[ -e "$S/$i" ] && {
			set_system_fp "$S/$i"
			DIRNAME="$(dirname "$S/$i")"
			chmod 0755 "$DIRNAME" && \
			file_log "I: $addon_name: dir set to 755 -> $DIRNAME" || \
			file_log "E: $addon_name: dir chmod 755 failed"
		}
	done
	
	# Remove tmp files
	file_log "I: $addon_name: removing waste $C"
	rm -rf $C
	[ -e $C ] && file_log "I: $addon_name: failed in removing waste $C, just remove it manually."
	
	# FLUSH THE FILE LOG TO THE LOGFILE
	LOG_FILE=/sdcard/logs/ufs/ota/"$addon_name"'_'$(date "+%Y-%m-%d_%H-%M-%S").log
	cat $COLD_TMP > $LOG_FILE
	# remove
	rm -rf $COLD_TMP
  ;;
esac

