#!/sbin/sh
#	
#	uniFlashScript
#
#	CodRLabworks
#	CodRCA : Christian Arvin
#

. /tmp/backuptool.functions


# INSTALLER.SH AUTOGENERATED DEF.
# _____________________________________________________________________________ <- 80 char
#

# ! AUTOGENERATED BY INSTALLER.SH !
addon_name=null
addon_src_ver=null
addon_app_rev=null

# ! AUTOGENERATED BY INSTALLER.SH !
wipe_list="
"

# ! AUTOGENERATED BY INSTALLER.SH !
list_files() {
cat <<EOF
#list_file_guide
EOF
}

# ! AUTOGENERATED BY INSTALLER.SH !
list_link(){
cat <<EOF
#list_link_guide
EOF
}

# Local Functions
# _____________________________________________________________________________ <- 80 char
#

# Restore File Links
link_files(){
	$LT3 "I: ASLIB list_link: Linking Files"
	local LM=;
	local BL="$C/BLNK"
	list_link | while read A B;do
		[ "$A" == "${A/#/}" ] && {
			LM=;
			mkdir -p `dirname $B`
			# compare backup to present file
			if [ ! -e "$A" ];then
				# check backup if exist
				[ -e "$BL$A" ] && {
					# copy so to lib and link to apk
					mkdir -p `dirname $A`
					copy_file "$BL$A" "$A"
					ln -sf "$A" "$B" &&\
					LM="RESTORED & LINKED"
				}
			else 
				(cmp "$A" "$BL$A") && {
					# the so are the same no need to restore, just link
					ln -sf "$A" "$B" && LM="LINKED           "
				} || {
					# the so are not the same we need to install the so
					copy_file "$BL$A" "$B"
					[ -e "$B" ] && LM="INSTALLED        "
				}
			fi
			[ -n "$LM" ] && \
				$LT3 "I: ASLIB link_files: $LM $B" || {
				$LT3 "E: ASLIB link_files: FAILED TO LINK $B"
				# calling manual so install
				extract_so_from_apk "$B"
			}
		}
	done
}

# Extract the so files from apk, when link restore fails
extract_so_from_apk(){
	local apk="$(echo $1 | cut -d/ -f4-4).apk";local apkpath="$(echo $1 | cut -d/ -f1-4)"
	local apksotarget="$(echo $1 | cut -d/ -f5-)";local apktarget="$apkpath/$apk"
	# test apk location
	if [ -e "$apktarget" ]; then
		# extract so from apk
		unzip -o "$apktarget" "$apksotarget" -d "$apkpath"
		# test so extraction
		[ -f "$1" ] && \
		$LT3 "I: ASLIB extract_so_from_apk: SO recovered from $apk" || \
		$LT3 "E: ASLIB extract_so_from_apk: failed to extract SO from APK, failing install.."
	else
		$LT3 "E: ASLIB extract_so_from_apk: Missing APK, ultimately failing SO install.."
	fi
}

# Backup Links
backup_link(){
	$LT3 "I: ASLIB backup_link: Backing up source of file links"
	local D=;local F=;local BL="$C/BLNK";
	[ -e "$BL" ] && rm -rf "$BL"
	mkdir -p "$BL"
	list_link | while read A DUMMY;do
		[ "$A" == "${A/#/}" ] && {
			D=`dirname $BL$A`;
			mkdir -p "$D"
			copy_file "$A" "$BL$A"
			[ -e "$BL$A" ] && \
				$LT3 "I: ASLIB backup_link: BACKUP $A" || \
				$LT3 "E: ASLIB backup_link: FAILED $A"
		}
	done
}


# Initial ui_print Function 
ui_print(){
	echo -n -e "ui_print $1\n" >> /proc/self/fd/$OUTFD
	echo -n -e "ui_print\n" >> /proc/self/fd/$OUTFD
	[ -n "$1" ] && file_log "$1"
}

# Cold Log
file_log() {
	[ -n "$1" ] && IN="$1" || read IN
	echo "$(date "+%H:%M:%S") $IN" >> $COLD_TMP
	printf "$IN\n"
}

# ASLIB EXPORTED FUNCTIONS
# _____________________________________________________________________________ <- 80 char
#

# REDIRECT ASLIB LOGGING TO LOCAL LOGGING
LT1=file_log;LT2=file_log;LT3=file_log;LT4=file_log;

##### ASLIB SET_PERM
set_perm() {
	$LT2 "I: ASLIB set_perm: setting permission $1 - $2 $3 $4 $5"
	[[ -n "$1" && -n "$2" && -n "$3" && -n "$4" ]] && {
		chown "$1.$2" "$4"	||\
		chown "$1:$2" "$4"	&&\
		chmod "$3" "$4"		&&\
		[ ! -d "$4" ] && ch_con "$4"
	}

	# Forced Return 0
	return 0
}

##### ASLIB.SUB.CH_CON
ch_con() {
	local P="u:object_r:system_file:s0"
	$LT4 "D: ASLIB ch_con: $1"
	! LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toybox chcon -h "$P" "$1"  && \
	! LD_LIBRARY_PATH=$SYSTEMLIB /system/toolbox chcon -h "$P" "$1"     && \
	! LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toolbox chcon -h "$P" "$1" && \
	chcon -h "$P" "$1"
	
	! LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toybox chcon "$P" "$1"     && \
	! LD_LIBRARY_PATH=$SYSTEMLIB /system/toolbox chcon "$P" "$1"        && \
	! LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toolbox chcon "$P" "$1"    && \
	chcon "$P" "$1"
}

##### ASLIB.ADD.PRINT_HEADER
print_header(){
	[ -z "$OUTFD" ] && init_fd
	set=0;local tmh_init=false;
	while true;do
		eval val='$'TMH$set
		if [ "$val" == "#" ];then
			ui_print " "
		elif [ -n "$val" ]; then
			ui_print "$val"
		elif [ -z "$val" ]; then
			# ignore the first blank TMH
			[ "$tmh_init" == "true" ] && {
				break
			}
			tmh_init=true
		fi
		set=$((++set))
	done
}

##### ASLIB.SUB.IS_MOUNTED
is_mounted() {
	$LT4 "D: ASLIB exec is_mounted with $1 $2"
	[ -n "$2" ] && {
		(cat /proc/mounts | grep $1 | grep -q -m 1 $2,)	&& s=0 || s=1
	} || {
		(cat /proc/mounts | grep -q -m 1 $1)			&& s=0 || s=1
	}
	[ "$s" == "0" ] && \
	$LT4 "D: ASLIB is_mounted: $1 is mounted $2" || \
	$LT4 "D: ASLIB is_mounted: $1 is not mounted"
	return $s
}

###### ASLIB.SUB.IS_ENABLED
is_enabled() {
	$LT4 "D: ASLIB exec is_enabled with $1"
	[ -z "$1" ] && return 1
	eval ie_t='$'$1
	case $ie_t in
		1|enable|true|True|TRUE|ENABLED|ENABLE) 
			$LT4 "I: ASLIB is_enabled: ENABLED, by $1 set to $ie_t"
			s=0
		;;
		0|disable|false|False|FALSE|DISABLED|DISABLE|' ')
			$LT4 "I: ASLIB is_enabled: DISABLED, by $1 set to $ie_t"
			s=1
		;;
		*) 	$LT4 "E: ASLIB is_enabled: unknown state of $1 set to $ie_t, returning 1"
			s=1
		;;
	esac
	return $s
}

##### ASLIB.SUB.TOOLBOX_MOUNT
toolbox_mount() {
	$LT4 "D: ASLIB exec toolbox_mount $1 $2"
	# default to READ_WRITE
	local RW=rw
	[ ! -z "$2" ] && RW=$2
	
	$LT4 "D: ASLIB toolbox_mount: mounting using using /etc/fstab entry"

	local DEV=;local POINT=;local FS=;
	
	for i in `cat /etc/fstab | grep -m 1 "$1"`; do
		if [ -z "$POINT" ]; then POINT=$i;elif [ -z "$FS" ]; then FS=$i;elif [ -z "$DEV" ]; then DEV=$i;break;fi
	done
	
	$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW $DEV $POINT"
	! mount -t $FS -o $RW $DEV $POINT               >/dev/null 2>&1 && \
	$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW,remount $DEV $POINT" && \
	! mount -t $FS -o $RW,remount $DEV $POINT       >/dev/null 2>&1 || return 0
	
	
	$LT4 "D: ASLIB toolbox_mount: mounting using using /etc/recovery.fstab"
	
	DEV=;POINT=;FS=;
	
	for i in `cat /etc/recovery.fstab | grep -m 1 "$1"`; do
		if [ -z "$POINT" ]; then POINT=$i;elif [ -z "$FS" ]; then FS=$i;elif [ -z "$DEV" ]; then DEV=$i;break;fi
	done
	
	if [ "$FS" = "emmc" ]; then
		$LT4 "D: ASLIB toolbox_mount: exec mount -t ext4 -o $RW $DEV $POINT"
		! mount -t ext4 -o $RW $DEV $POINT            >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t ext4 -o $RW,remount $DEV $POINT" && \
		! mount -t ext4 -o $RW,remount $DEV $POINT    >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t f2fs -o $RW $DEV $POINT" && \
		! mount -t f2fs -o $RW $DEV $POINT            >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t f2fs -o $RW,remount $DEV $POINT" && \
		! mount -t f2fs -o $RW,remount $DEV $POINT    >/dev/null 2>&1 || return 0
	else
		$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW $DEV $POINT"
		! mount -t $FS -o $RW $DEV $POINT             >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW,remount $DEV $POINT" && \
		! mount -t $FS -o $RW,remount $DEV $POINT     >/dev/null 2>&1 || return 0
	fi
	return 1 # FAILED TO MOUNT
}

##### ASLIB.SUB.REMOUNT_MOUNTPOINT
remount_mountpoint() {
	$LT4 "D: ASLIB exec remount_mountpoint"
	[ -n "$*" ] && {
		! is_mounted $1 $2 && \
		$LT4 "D: ASLIB remount_mountpoint: exec mount -o $2,remount $1" && \
		! mount -o $2,remount $1    >/dev/null 2>&1 && \
		$LT4 "D: ASLIB remount_mountpoint: exec mount -o $2,remount $1 $1" && \
		! mount -o $2,remount $1 $1 >/dev/null 2>&1 && \
		$LT4 "D: ASLIB remount_mountpoint: exec toolbox_mount $1" && \
		! toolbox_mount $1          >/dev/null 2>&1 && \
		{
			$LT3 "I: ASLIB remount_mountpoint: $1 failed to remount"
			return 1
		} || {
			$LT3 "I: ASLIB remount_mountpoint: $1 remounted successfully"
			return 0
		}
	}
}

###### ASLIB.SUB.SET_SYSTEM_FP
set_system_fp() {
	[ -n "${1##*/system*}" ] && {
		$LT2 "E: ASLIB set_system_fp: not valid system file input $1 only system files with full path are accepted"
		return 0;
	}
	
	# if bin xbin sbin
	if [[ -f "$1" && -z "${1##*/bin*}" || -z "${1##*/xbin*}" || -z "${1##*/sbin*}" ]]; then
		set_perm 0 2000 0755 "$1" && \
		chmod +x "$1"
	else
		local CM=;
		[ -f "$1" ] && CM=0644 || CM=0755
		set_perm 0 0 $CM "$1"
	fi
	
	return 0
}


#### ASLIB GET_FILE_PROP
get_file_prop(){
	local pf=;local pv=;
	if [ -f "$1" ];then
		pf="$1";pv="$2"
	elif [ -f "$2" ];then
		pf="$2";pv="$1"
	else
		$LT3 "E: ASLIB get_file_prop: No valid file"
		return 1
	fi
	grep -m 1 "^$pv=" "$pf" | cut -d= -f2
}



# Pre-Initialization
# _____________________________________________________________________________ <- 80 char
#

# CREATE A TEMP. PLACEHOLDER FOR LOGGING
COLD_TMP=/tmp/$addon_name.log

# CREATE THE COLD LOG HEADER
[ ! -e $COLD_TMP ] && {
	file_log "\n"
	file_log "uniFlashScript addon.d logs"
	file_log " "
	file_log "$addon_name"
	file_log "src ver. : $addon_src_ver"
	file_log "src rev. : $addon_app_rev"$'\n\n'
}

# CUSTOM UI_PRINT HEADER
# ! LEAVE THIS PART !
TMH0=""
TMH1="#"
# ! BEGIN HEADER HERE !
TMH2=""

# FD FAILSAFE
[ -z "$OUTFD" ] &&\
OUTFD=`ps | grep -v grep | grep -oE "update(.*)" | cut -d" " -f3`

# Initialization
# _____________________________________________________________________________ <- 80 char
#

# CREATE THE DIRECTORY OTA LOG
# by uniFlashScript standard..
[ ! -e /sdcard/logs/ufs/ota ] && {
	file_log "I: $addon_name: creating ota directory"
	install -d /sdcard/logs/ufs/ota
}

# OVIRRIDE C DEF. AND REDIRECT TO SDCARD
C=/sdcard/tmp/tmp_ufs_ota

# CREATE TEMP FILE HOLDER
[ ! -e $C ] && mkdir $C

[ -z "$SYSTEMLIB" ] && {
	case "$(get_file_prop /system/build.prop ro.product.cpu.abilist)" in 
		*arm64*)
			LIB=lib64
			;;
		*amreabi*)
			LIB=lib
			;;
		*mips64*)
			LIB=mips64
			;;
		*mips*)
			LIB=mips
			;;
		*x86*)
			LIB=x86
			;;
		*x86_64*)
			LIB=x86_64
			;;
	esac

	SYSTEMLIB=/system/$LIB:/vendor/$LIB
}

# Main
# _____________________________________________________________________________ <- 80 char
#

case "$1" in
  backup)
	# print_header
	TMH1="backup $addon_name "
	print_header
	
	# Safely Check that SDCARD is mounted
	remount_mountpoint /sdcard rw
	
	# Backup
	file_log "I: backup: backing_up files"
	list_files | while read FILE DUMMY; do
		[ -e "$S/$FILE" ] && {
			backup_file "$S/$FILE"
			[ -e "$C/system/$FILE" ] && \
			file_log "I: backup: success :$C/system/$FILE" ||\
			file_log "E: backup: FAILED  :$S/$FILE"
		}
	done
	
	# backup links
	backup_link;
	
  ;;
  restore)
	# print_header
	TMH1="restore $addon_name "
	print_header
	
	# Safely Check that SDCARD is mounted
	remount_mountpoint /sdcard rw
	
	file_log "I: restore: wiping files"
	# Wipe files
	for m in $wipe_list;do
		[ -e /system/$m ] && {
			rm -rf /system/$m && \
			file_log "I: restore: removed :/system/$m" || \
			file_log "E: restore: FAILED  :/system/$m"
		}
	done
	
	# Install
	file_log "I: restore: restoring files"
	list_files | while read FILE REPLACEMENT; do
		R=""
		[ -n "$REPLACEMENT" ] && R="$S/$REPLACEMENT"
		[ -f "$C/$S/$FILE"  ] && (
			restore_file $S/"$FILE" "$R"
			[ -e $S/"$FILE" ] &&\
			file_log "I: restore: installed :$S/$FILE" ||\
			file_log "E: restore: FAILED    :$S/$FILE"
		)
	done
	
  ;;
  pre-backup)
	# Stub
  ;;
  post-backup)
	# Stub
  ;;
  pre-restore)
	# Stub
  ;;
  post-restore)
	# print_header
	TMH1="post-restore $addon_name "
	print_header
	
	# Restore Links
	link_files
	
	# Setup Correct Permissions
	file_log "I: post-restore: setting permisions"
	for i in $(list_files); do
		[ -e "$S/$i" ] && {
			set_system_fp "$S/$i"
			DN="$(dirname "$S/$i")"
			chmod 0755 "$DN"
		}
	done
	
	# Remove tmp files
	file_log "I: post-restore: removing waste $C"
	rm -rf "$C"
	[ -e $C ] && file_log "I: post-restore: failed in removing waste $C, just remove it manually."
	
	# FLUSH THE FILE LOG TO THE LOGFILE
	LOG_FILE=/sdcard/logs/ufs/ota/"$addon_name"'_'$(date "+%Y-%m-%d_%H-%M-%S").log
	cat $COLD_TMP > $LOG_FILE
	# remove
	rm -rf $COLD_TMP
  ;;
esac

